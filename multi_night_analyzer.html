<!DOCTYPE html>
<html lang="en-GB">
<head>
<title>Multi-Night Glasgow Index Analyzer</title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link rel="icon" href="favicon.ico" type="image/x-icon" />

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="EDFFile.js"></script>
<script src="FlowLimits.js"></script>

<style>
    body {
        font-family: sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
    }
    
    .container {
        max-width: 1200px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .header {
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 20px;
    }
    
    .upload-section {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 2px dashed #ccc;
    }
    
    .upload-section.drag-over {
        border-color: #007bff;
        background-color: #e7f3ff;
    }
    
    .results-section {
        display: none;
        margin-top: 20px;
    }
    
    .summary-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }
    
    .summary-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #007bff;
        text-align: center;
    }
    
    .summary-card h3 {
        margin: 0 0 10px 0;
        color: #333;
        font-size: 14px;
    }
    
    .summary-card .value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
    }
    
    .chart-container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    
    .night-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        background-color: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    
    .night-table th,
    .night-table td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .night-table th {
        background-color: #007bff;
        color: white;
        font-weight: bold;
    }
    
    .night-table tr:hover {
        background-color: #f8f9fa;
    }
    
    .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
    }
    
    .progress-fill {
        height: 100%;
        background-color: #007bff;
        transition: width 0.3s ease;
    }
    
    .file-count {
        margin: 10px 0;
        color: #666;
    }
    
    .gi-value {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: bold;
    }
    
    .gi-excellent { background-color: #d4edda; color: #155724; }
    .gi-good { background-color: #d1ecf1; color: #0c5460; }
    .gi-fair { background-color: #fff3cd; color: #856404; }
    .gi-poor { background-color: #f8d7da; color: #721c24; }
    .gi-very-poor { background-color: #f5c6cb; color: #491217; }
    
    /* Header info pills */
    .info-pills {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        margin-top: 10px;
    }
    .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid #e0e0e0;
        background: #fafafa;
        color: #333;
        box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    .pill a { color: #007bff; text-decoration: none; }
    .pill a:hover { text-decoration: underline; }
    .pill--contact { border-color: #cfe2ff; background: #f0f6ff; }
    .pill--privacy { border-color: #d1e7dd; background: #f3fff6; }
    .pill--source { border-color: #ffe69c; background: #fff9e6; }
    .ack-line { margin-top: 8px; font-size: 12px; color: #666; }
</style>

</head>
<body>

<div class="container">
    <div class="header">
        <h1>Multi-Night Glasgow Index Analyzer</h1>
        <p>Analyze multiple nights of ResMed PAP data to track Glasgow Index trends and component analysis</p>
        <div class="info-pills">
            <span class="pill pill--contact">üì¨ Feature request? <a href="mailto:vibecoder75321@gmail.com">vibecoder75321@gmail.com</a></span>
            <span class="pill pill--privacy">üîí All processing happens locally in your browser</span>
            <span class="pill pill--source">üîó <a href="https://github.com/VibeCoder75321/Multi-Night-Glasgow-Index-Analyzer" target="_blank" rel="noopener noreferrer">Project on GitHub</a></span>
        </div>
        <div class="ack-line">Acknowledgment: Original Glasgow Index by <a href="https://github.com/DaveSkvn/GlasgowIndex" target="_blank" rel="noopener noreferrer">DaveSkvn</a></div>
    </div>
    
          <div class="upload-section" id="uploadSection">
          <h3>Upload Entire SD Card Data for complete analysis</h3>
          <!-- <p><strong>For complete analysis including pressure settings, machine type, and all Glasgow Index data:</strong></p> -->
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
              <div style="text-align: center; padding: 20px; border: 2px solid #007bff; border-radius: 8px; background: #f8f9ff;">
                  <h4 style="margin-top: 0; color: #007bff;">üìÅ Upload Entire SD Card</h4>
                  <p style="font-size: 14px; color: #666; margin-bottom: 15px;"><strong>Recommended:</strong> Select your entire ResMed SD card root folder</p>
                  <input type="file" id="folderInput" webkitdirectory multiple style="margin: 10px 0;">
                  <div style="font-size: 12px; color: #333; margin-top: 10px; font-weight: bold;">
                      <!-- ‚úÖ Includes: DATALOG, STR.edf, Identification.tgt, SETTINGS -->
                  </div>
                  <div style="font-size: 11px; color: #666; margin-top: 5px;">
                      <!-- Extracts: Machine Type, IPAP, EPAP, Pressure Support, PAP Mode -->
                  </div>
              </div>
              
              <div style="text-align: center; padding: 20px; border: 2px dashed #ffc107; border-radius: 8px; background: #fffbf0;">
                  <h4 style="margin-top: 0; color: #856404;">üìÑ Or Upload Individual Files</h4>
                  <p style="font-size: 14px; color: #666; margin-bottom: 15px;">Helpful to review a single night or an OSCAR Backup</p>
                  <input type="file" name="inputfiles" id="fileInput" multiple accept=".edf" style="margin: 10px 0;">
                  <div style="font-size: 12px; color: #856404; margin-top: 10px; font-weight: bold;">
                      ‚ö†Ô∏è Limited: Glasgow Index only
                  </div>
                  <div style="font-size: 11px; color: #666; margin-top: 5px;">
                      <!-- Missing: Pressure data, machine settings -->
                  </div>
              </div>
          </div>
          
          
          <div class="file-count" id="fileCount">No files selected</div>
          <div class="progress-bar" id="progressBar" style="display: none;">
              <div class="progress-fill" id="progressFill"></div>
          </div>
          <div id="processingStatus"></div>
      </div>
    
    <div class="results-section" id="resultsSection">
        <div class="summary-cards">
            <div class="summary-card">
                <h3>Nights Analyzed</h3>
                <div class="value" id="nightsCount">0</div>
            </div>
            <div class="summary-card">
                <h3>Average Overall GI</h3>
                <div class="value" id="avgOverallGI">0.00</div>
            </div>
            <div class="summary-card">
                <h3>Best Night GI</h3>
                <div class="value" id="bestNightGI">0.00</div>
            </div>
            <div class="summary-card">
                <h3>Worst Night GI</h3>
                <div class="value" id="worstNightGI">0.00</div>
            </div>
        </div>
        <div class="chart-container">
            <h3>Glasgow Index Trends Over Time</h3>
            <div style="margin-bottom: 15px;">
                <label for="dateRangeSelect">Date Range:</label>
                <select id="dateRangeSelect" style="margin: 0 10px; padding: 5px;" onchange="onDateRangeChange(); updateAllCharts()">
                    <option value="all">All Data</option>
                    <option value="30">Last 30 Days</option>
                    <option value="60">Last 60 Days</option>
                    <option value="90">Last 90 Days</option>
                    <option value="custom">Custom‚Ä¶</option>
                </select>
                <span id="customDateBlock" style="display: none;">
                    <input type="date" id="customStartDate" style="padding: 5px; margin-right: 6px;">
                    <input type="date" id="customEndDate" style="padding: 5px; margin-right: 10px;">
                </span>
                
                <label for="smoothingSelect">Smoothing:</label>
                <select id="smoothingSelect" style="margin: 0 10px; padding: 5px;">
                    <option value="none">None</option>
                    <option value="3">3-day Moving Average</option>
                    <option value="7">7-day Moving Average</option>
                    <option value="14">14-day Moving Average</option>
                </select>
                <label style="margin-left: 10px;">
                    <input type="checkbox" id="hideShortNights" checked onchange="updateAllCharts()"> Hide Nights &lt;4 Hours
                </label>
                
                <button onclick="updateAllCharts()" style="padding: 5px 15px;">Update Charts</button>
            </div>
            <div style="position: relative; height: 400px; width: 100%;">
                <canvas id="trendsChart"></canvas>
            </div>
        </div>
        
        <div class="chart-container">
            <h3>Component Analysis</h3>
            <div style="margin-bottom: 15px;">
                <label>
                    <input type="checkbox" id="showTrendLines" checked onchange="updateComponentsChart()"> 
                    Show Trend Lines
                </label>
            </div>
            
            <!-- Component Filter Panel -->
            <div id="componentFilter" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; margin-bottom: 10px;">Select Components to Display:</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px;">
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_skew" checked onchange="updateComponentsChart()"> Skew</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_spike" checked onchange="updateComponentsChart()"> Spike</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_flatTop" checked onchange="updateComponentsChart()"> Flat Top</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_topHeavy" checked onchange="updateComponentsChart()"> Top Heavy</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_multiPeak" checked onchange="updateComponentsChart()"> Multi Peak</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_noPause" checked onchange="updateComponentsChart()"> No Pause</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_inspirRate" checked onchange="updateComponentsChart()"> Inspir Rate</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_multiBreath" checked onchange="updateComponentsChart()"> Multi Breath</label>
                    <label style="font-size: 13px;"><input type="checkbox" id="comp_ampVar" checked onchange="updateComponentsChart()"> Variable Amp</label>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="selectAllComponents()" style="padding: 4px 8px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 3px;">All</button>
                    <button onclick="selectNoComponents()" style="padding: 4px 8px; font-size: 12px; background: #dc3545; color: white; border: none; border-radius: 3px;">None</button>
                    <button onclick="selectMainComponents()" style="padding: 4px 8px; font-size: 12px; background: #007bff; color: white; border: none; border-radius: 3px;">Main Issues</button>
                    <button onclick="selectFlowComponents()" style="padding: 4px 8px; font-size: 12px; background: #6f42c1; color: white; border: none; border-radius: 3px;">Flow Shape</button>
                    <button onclick="selectTimingComponents()" style="padding: 4px 8px; font-size: 12px; background: #fd7e14; color: white; border: none; border-radius: 3px;">Timing</button>
                </div>
            </div>
            
            <div style="position: relative; height: 400px; width: 100%;">
                <canvas id="componentsChart"></canvas>
            </div>
        </div>
        
        <!-- Moved Heatmap block to just above the detailed table -->
        <div class="chart-container">
            <h3 style="margin-bottom: 10px;">Night Heatmap</h3>
            <div style="margin-bottom: 10px;">
                <label for="nightSelect" style="margin-right: 8px;">Select Night:</label>
                <button id="nightPrev" onclick="prevNight()" title="Older night" style="padding: 4px 8px; margin-right: 6px;">‚óÄ</button>
                <select id="nightSelect" onchange="updateNightHeatmap()" style="padding: 5px 8px; margin-right: 6px;"></select>
                <button id="nightNext" onclick="nextNight()" title="Newer night" style="padding: 4px 8px;">‚ñ∂</button>
            </div>
            <div style="position: relative; height: 380px; width: 100%;">
                <canvas id="chartTop"></canvas>
            </div>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0;">Detailed Night-by-Night Results</h3>
            <button onclick="exportNightlyCSV()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                üìä Export to CSV
            </button>
        </div>
        <table class="night-table" id="resultsTable">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Start Time</th>
                    <th>Duration (hrs)</th>
                    <th>Machine Type</th>
                    <th>Overall GI</th>
                    <th>Skew</th>
                    <th>Spike</th>
                    <th>Flat Top</th>
                    <th>Top Heavy</th>
                    <th>Multi Peak</th>
                    <th>No Pause</th>
                    <th>Inspir Rate</th>
                    <th>Multi Breath</th>
                    <th>Variable Amp</th>
                    <th>IPAP</th>
                    <th>EPAP</th>
                    <th>Pressure Support</th>
                    <th>EasyBreathe</th>
                    <th>Rise Time</th>
                    <th>Trigger</th>
                    <th>Cycle</th>
                </tr>
            </thead>
            <tbody id="resultsTableBody">
            </tbody>
        </table>
    </div>
</div>

<!-- Release Notes (collapsed by default) -->
<div class="container" style="margin-top: 16px;">
    <details>
        <summary style="cursor:pointer; font-weight:600;">Release Notes ‚Äî Updated: <span id="releaseNotesDate">2025-09-27</span></summary>
        <div style="margin-top:10px; font-size: 14px; color: #222; line-height: 1.6;">
            <div style="background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px; padding:12px;">
                <div style="font-weight:bold; margin-bottom:6px;">What's new</div>
                <ul style="margin:0 0 8px 18px;">
                    <li>STR.edf settings extraction: <code>S.RiseTime</code>, <code>S.Trigger</code>, <code>S.Cycle</code>, <code>S.EasyBreathe</code></li>
                    <li>Per-night display and CSV export for machine settings</li>
                </ul>
                <div style="font-weight:bold; margin-bottom:6px;">Improvements</div>
                <ul style="margin:0 0 8px 18px;">
                    <li>When EasyBreathe is <strong>On</strong>, Rise Time is shown as <strong>N/A</strong></li>
                    <li>Trigger/Cycle labels: 4=very high, 3=high, 2=medium, 1=low, 0=very low</li>
                    <li>Table/CSV order: Pressure Support, EasyBreathe, Rise Time, Trigger, Cycle</li>
                </ul>
                <div style="font-weight:bold; margin-bottom:6px;">UX</div>
                <ul style="margin:0 0 8px 18px;">
                    <li>Header pills for contact, privacy, source, plus acknowledgment</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<script type="text/javascript">

let nightlyResults = [];
let trendsChart = null;
let componentsChart = null;

// File handling
document.getElementById('fileInput').addEventListener('change', function (event) {
    const files = Array.from(event.target.files);
    handleFiles(files);
});

// Folder handling
document.getElementById('folderInput').addEventListener('change', function (event) {
    const files = Array.from(event.target.files);
    handleFiles(files);
});

// Enhanced drag and drop functionality
const uploadSection = document.getElementById('uploadSection');

uploadSection.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadSection.classList.add('drag-over');
});

uploadSection.addEventListener('dragleave', function(e) {
    e.preventDefault();
    uploadSection.classList.remove('drag-over');
});

uploadSection.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadSection.classList.remove('drag-over');
    
    const files = [];
    const items = e.dataTransfer.items;
    
    if (items) {
        // Handle both files and directories
        const promises = [];
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    promises.push(processEntry(entry));
                }
            }
        }
        
        Promise.all(promises).then(results => {
            const allFiles = results.flat().filter(file => file.name.endsWith('.edf'));
            if (allFiles.length > 0) {
                handleFiles(allFiles);
            } else {
                alert('No EDF files found in the dropped items. Please ensure you\'re dropping folders containing ResMed data or individual EDF files.');
            }
        });
    } else {
        // Fallback for browsers that don't support webkitGetAsEntry
        const fileList = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.edf'));
        if (fileList.length > 0) {
            handleFiles(fileList);
        }
    }
});

// Process directory entries recursively
function processEntry(entry) {
    return new Promise((resolve) => {
        if (entry.isFile) {
            entry.file(resolve);
        } else if (entry.isDirectory) {
            const dirReader = entry.createReader();
            dirReader.readEntries((entries) => {
                const promises = entries.map(processEntry);
                Promise.all(promises).then(results => {
                    resolve(results.flat());
                });
            });
        }
    });
}

function handleFiles(files) {
    const brpFiles = files.filter(file => file.name.includes('_BRP.edf'));
    const identificationFiles = files.filter(file => 
        file.name === 'Identification.tgt' || 
        file.name === 'Identification.json'
    );
    const strFiles = files.filter(file => file.name === 'STR.edf');
    const allEdfFiles = files.filter(file => file.name.endsWith('.edf'));
    
    if (brpFiles.length === 0) {
        if (allEdfFiles.length > 0) {
            const otherTypes = allEdfFiles.map(f => {
                if (f.name.includes('_PLD.edf')) return 'PLD (pressure data)';
                if (f.name.includes('_SAD.edf')) return 'SAD (summary data)';
                if (f.name.includes('_EVE.edf')) return 'EVE (event data)';
                return 'unknown type';
            });
            
            alert(`Found ${allEdfFiles.length} EDF files, but none are BRP (breathing) files needed for analysis.\n\nFound: ${[...new Set(otherTypes)].join(', ')}\n\nPlease ensure your folders contain BRP.edf files from your ResMed device.`);
        } else {
            alert('No EDF files found. Please select folders containing ResMed data or individual BRP.edf files.');
        }
        return;
    }
    
    // Group files by night to show better summary
    const nightGroups = {};
    brpFiles.forEach(file => {
        const match = file.name.match(/(\d{8})_/);
        if (match) {
            const date = match[1];
            if (!nightGroups[date]) nightGroups[date] = 0;
            nightGroups[date]++;
        }
    });
    
    const nightCount = Object.keys(nightGroups).length;
    const sessionCount = brpFiles.length;
    
    let countText = `Found ${sessionCount} breathing data files from ${nightCount} night${nightCount !== 1 ? 's' : ''}`;
    
    if (allEdfFiles.length > brpFiles.length) {
        const otherCount = allEdfFiles.length - brpFiles.length;
        countText += ` (${otherCount} other EDF files ignored)`;
    }
    
    // Show which nights were found
    if (nightCount <= 10) {
        const nightDates = Object.keys(nightGroups).sort().map(date => {
            const sessionCount = nightGroups[date];
            const formattedDate = `${date.slice(0,4)}-${date.slice(4,6)}-${date.slice(6,8)}`;
            return sessionCount > 1 ? `${formattedDate} (${sessionCount} sessions)` : formattedDate;
        });
        countText += `\n\nNights: ${nightDates.join(', ')}`;
    }
    
    document.getElementById('fileCount').textContent = countText;
    processFiles(brpFiles, identificationFiles, strFiles);
}

async function processFiles(brpFiles, identificationFiles = [], strFiles = []) {
    nightlyResults = [];
    
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const processingStatus = document.getElementById('processingStatus');
    
    progressBar.style.display = 'block';
    
    // Parse machine identification first
    let machineInfo = null;
    if (identificationFiles.length > 0) {
        try {
            processingStatus.textContent = 'Reading machine identification...';
            machineInfo = await parseMachineIdentification(identificationFiles[0]);
            console.log('Detected machine:', machineInfo);
        } catch (error) {
            console.error('Error parsing machine identification:', error);
        }
    }
    
    // Parse STR file for pressure settings
    let pressureSettings = null;
    if (strFiles.length > 0) {
        try {
            processingStatus.textContent = 'Reading pressure settings...';
            pressureSettings = await parseSTRFile(strFiles[0]);
            console.log('Extracted pressure settings:', pressureSettings);
        } catch (error) {
            console.error('Error parsing STR file:', error);
        }
    }
    
    for (let i = 0; i < brpFiles.length; i++) {
        const file = brpFiles[i];
        const progress = ((i + 1) / brpFiles.length) * 100;
        progressFill.style.width = progress + '%';
        processingStatus.textContent = `Processing ${file.name}...`;
        
        try {
            const result = await processFile(file, machineInfo, pressureSettings);
            if (result) {
                nightlyResults.push(result);
            }
        } catch (error) {
            console.error(`Error processing ${file.name}:`, error);
        }
        
        // Small delay to allow UI to update
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    progressBar.style.display = 'none';
    processingStatus.textContent = '';
    
    if (nightlyResults.length > 0) {
        displayResults();
    } else {
        alert('No files could be processed successfully');
    }
}

function processFile(file, machineInfo = null, pressureSettings = null) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const arrayBuffer = event.target.result;
                const result = analyzeFile(arrayBuffer, file.name, machineInfo, pressureSettings);
                resolve(result);
            } catch (error) {
                console.error(`Error processing file ${file.name}:`, error);
                resolve(null);
            }
        };
        
        reader.onerror = function() {
            reject(new Error(`Failed to read file ${file.name}`));
        };
        
        reader.readAsArrayBuffer(file);
    });
}

function analyzeFile(arrayBuffer, fileName, machineInfo = null, pressureSettings = null) {
    // Parse EDF file
    const fileData = parseEDFFile(arrayBuffer);
    if (fileData.formatVersion !== "0") {
        throw new Error("Incorrect file format");
    }
    
    // Extract flow data
    const dataArray = formDataArray(fileData);
    if (!dataArray || dataArray.length === 0) {
        throw new Error("No flow data found");
    }
    
    // Run Glasgow Index analysis
    const results = {};
    
    findMins(dataArray);
    findInspirations(dataArray, results);
    calcCycleBasedIndicators(dataArray, results);
    prepIdealFlow(dataArray, results);
    inspirationAmplitude(dataArray, results);
    results.cumIndex = prepIndices(results);
    
    // Calculate session duration in hours
    const durationMs = dataArray.length * 40; // 40ms per sample
    const durationHours = durationMs / (1000 * 60 * 60);
    
    // Extract date and time from filename
    const match = fileName.match(/(\d{8})_(\d{6})_BRP\.edf/);
    let date = 'Unknown';
    let time = 'Unknown';
    
    if (match) {
        const dateStr = match[1];
        const timeStr = match[2];
        
        date = `${dateStr.slice(0,4)}-${dateStr.slice(4,6)}-${dateStr.slice(6,8)}`;
        time = `${timeStr.slice(0,2)}:${timeStr.slice(2,4)}:${timeStr.slice(4,6)}`;
    }
    
    // Extract pressure data for this session date
    let sessionPressure = getSessionPressureData(pressureSettings, date);
    // Extract additional machine settings from pressureSettings (per-date), if available
    const sessionExtras = sessionPressure || {};
    
    // Apply EasyBreathe logic at the session level: if On, Rise Time is N/A
    const easyOn = (sessionExtras && typeof sessionExtras.easyBreathe === 'string' && sessionExtras.easyBreathe === 'On');
    const finalRiseTime = easyOn ? 'N/A' : ((sessionExtras && sessionExtras.riseTime !== undefined) ? sessionExtras.riseTime : 'N/A');
    
    return {
        fileName: fileName,
        date: date,
        time: time,
        startDateTime: fileData.startDateTime,
        duration: durationHours,
        cumIndex: results.cumIndex,
        inspirationCount: results.inspirations ? results.inspirations.length : 0,
        inspirations: results.inspirations || [],
        sampleCount: (results.inspirations && results.inspirations.length > 0) ? results.inspirations[results.inspirations.length - 1].end : (dataArray ? dataArray.length : 0),
        machineType: machineInfo ? machineInfo.type : 'Unknown',
        ipap: sessionPressure ? sessionPressure.ipap : 'N/A',
        epap: sessionPressure ? sessionPressure.epap : 'N/A',
        papMode: sessionPressure ? sessionPressure.mode : 'Unknown',
        riseTime: finalRiseTime,
        trigger: (sessionExtras && sessionExtras.trigger !== undefined) ? sessionExtras.trigger : 'N/A',
        cycle: (sessionExtras && sessionExtras.cycle !== undefined) ? sessionExtras.cycle : 'N/A',
        easyBreathe: (sessionExtras && sessionExtras.easyBreathe !== undefined) ? sessionExtras.easyBreathe : 'N/A'
    };
}

function displayResults() {
    // Sort results by date/time
    nightlyResults.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
    
    // Group by night (same date, combine sessions)
    const nightlyData = groupByNight(nightlyResults);
    
    // Update summary cards
    updateSummaryCards(nightlyData);
    
    // Create charts
    createTrendsChart(nightlyData);
    createComponentsChart(nightlyData);
    
    // Create results table
    createResultsTable(nightlyData);
    
    // Populate selector and render heatmap
    populateNightSelector(nightlyData);
    renderMostRecentNightHeatmap(nightlyData);
    
    // Show results section
    document.getElementById('resultsSection').style.display = 'block';
}

function groupByNight(results) {
    const grouped = {};
    
    results.forEach(result => {
        // Convert sessions to sleep nights
        // Sessions starting between 6 PM and 11:59 PM belong to that date's night
        // Sessions starting between 12:00 AM and 11:59 AM belong to previous date's night
        const sessionDateTime = new Date(result.startDateTime);
        const sessionHour = sessionDateTime.getHours();
        
        let sleepNightDate;
        if (sessionHour >= 18) {
            // Evening session (6 PM - 11:59 PM) - belongs to current date's night
            sleepNightDate = result.date;
        } else if (sessionHour < 12) {
            // Morning session (12:00 AM - 11:59 AM) - belongs to previous date's night
            const prevDate = new Date(sessionDateTime);
            prevDate.setDate(prevDate.getDate() - 1);
            sleepNightDate = prevDate.toISOString().split('T')[0];
        } else {
            // Afternoon session (12:00 PM - 5:59 PM) - unusual, but belongs to current date
            sleepNightDate = result.date;
        }
        
        if (!grouped[sleepNightDate]) {
            grouped[sleepNightDate] = [];
        }
        grouped[sleepNightDate].push(result);
    });
    
    // Calculate weighted averages for each night
    const nightlyData = [];
    
    Object.keys(grouped).forEach(sleepNightDate => {
        const sessions = grouped[sleepNightDate];
        const totalDuration = sessions.reduce((sum, s) => sum + s.duration, 0);
        
        // Calculate weighted averages
        const weightedGI = {
            overall: 0,
            skew: 0,
            spike: 0,
            flatTop: 0,
            topHeavy: 0,
            multiPeak: 0,
            noPause: 0,
            inspirRate: 0,
            multiBreath: 0,
            ampVar: 0
        };
        
        sessions.forEach(session => {
            const weight = session.duration / totalDuration;
            weightedGI.skew += session.cumIndex.skew * weight;
            weightedGI.spike += session.cumIndex.spike * weight;
            weightedGI.flatTop += session.cumIndex.flatTop * weight;
            weightedGI.topHeavy += session.cumIndex.topHeavy * weight;
            weightedGI.multiPeak += session.cumIndex.multiPeak * weight;
            weightedGI.noPause += session.cumIndex.noPause * weight;
            weightedGI.inspirRate += session.cumIndex.inspirRate * weight;
            weightedGI.multiBreath += session.cumIndex.multiBreath * weight;
            weightedGI.ampVar += session.cumIndex.ampVar * weight;
        });
        
        // Round to 2 decimal places
        Object.keys(weightedGI).forEach(key => {
            weightedGI[key] = Math.round(weightedGI[key] * 100) / 100;
        });
        
        // Calculate overall GI as sum of all 9 components (corrected calculation)
        weightedGI.overall = Math.round((weightedGI.skew + weightedGI.spike + weightedGI.flatTop + 
                                        weightedGI.topHeavy + weightedGI.multiPeak + weightedGI.noPause + 
                                        weightedGI.inspirRate + weightedGI.multiBreath + weightedGI.ampVar) * 100) / 100;
        
        // Sort sessions by start time to get the earliest session time
        sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
        
        // Calculate weighted average pressures (for APAP mode, these will be the Min values as requested)
        let weightedIPAP = 'N/A';
        let weightedEPAP = 'N/A';
        let nightMode = 'Unknown';
        let weightedRiseTime = 'N/A';
        let weightedTrigger = 'N/A';
        let weightedCycle = 'N/A';
        let weightedEasyBreathe = 'N/A';
        
        const validIPAP = sessions.filter(s => s.ipap !== 'N/A' && !isNaN(parseFloat(s.ipap)));
        const validEPAP = sessions.filter(s => s.epap !== 'N/A' && !isNaN(parseFloat(s.epap)));
        
        if (validIPAP.length > 0) {
            const totalIPAPDuration = validIPAP.reduce((sum, session) => sum + session.duration, 0);
            if (totalIPAPDuration > 0) {
                weightedIPAP = validIPAP.reduce((sum, session) => {
                    const weight = session.duration / totalIPAPDuration;
                    return sum + (parseFloat(session.ipap) * weight);
                }, 0);
                weightedIPAP = Math.round(weightedIPAP * 10) / 10;
            }
        }
        
        if (validEPAP.length > 0) {
            const totalEPAPDuration = validEPAP.reduce((sum, session) => sum + session.duration, 0);
            if (totalEPAPDuration > 0) {
                weightedEPAP = validEPAP.reduce((sum, session) => {
                    const weight = session.duration / totalEPAPDuration;
                    return sum + (parseFloat(session.epap) * weight);
                }, 0);
                weightedEPAP = Math.round(weightedEPAP * 10) / 10;
            }
        }
        
        // Get mode from first session (should be consistent for the night)
        if (sessions.length > 0 && sessions[0].papMode) {
            nightMode = sessions[0].papMode;
        }
        
                    // Calculate pressure support (IPAP - EPAP)
            let pressureSupport = 'N/A';
            if (weightedIPAP !== 'N/A' && weightedEPAP !== 'N/A') {
                pressureSupport = Math.round((weightedIPAP - weightedEPAP) * 10) / 10;
            }
            
            // Compute duration-weighted extra settings if numeric
            const validRise = sessions.filter(s => s.riseTime !== 'N/A' && !isNaN(parseFloat(s.riseTime)));
            if (validRise.length > 0) {
                const total = validRise.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) {
                    weightedRiseTime = Math.round(validRise.reduce((sum, s) => sum + parseFloat(s.riseTime) * (s.duration / total), 0));
                }
            }
            const validTrig = sessions.filter(s => s.trigger !== 'N/A' && !isNaN(parseFloat(s.trigger)));
            if (validTrig.length > 0) {
                const total = validTrig.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) {
                    weightedTrigger = Math.round(validTrig.reduce((sum, s) => sum + parseFloat(s.trigger) * (s.duration / total), 0));
                }
            }
            const validCycle = sessions.filter(s => s.cycle !== 'N/A' && !isNaN(parseFloat(s.cycle)));
            if (validCycle.length > 0) {
                const total = validCycle.reduce((sum, s) => sum + s.duration, 0);
                if (total > 0) {
                    weightedCycle = Math.round(validCycle.reduce((sum, s) => sum + parseFloat(s.cycle) * (s.duration / total), 0));
                }
            }
            const validEB = sessions.filter(s => typeof s.easyBreathe === 'string');
            if (validEB.length > 0) {
                // Choose majority value by duration
                const onDur = validEB.filter(s => s.easyBreathe === 'On').reduce((sum, s) => sum + s.duration, 0);
                const offDur = validEB.filter(s => s.easyBreathe === 'Off').reduce((sum, s) => sum + s.duration, 0);
                if (onDur > 0 || offDur > 0) {
                    weightedEasyBreathe = onDur >= offDur ? 'On' : 'Off';
                }
            }

            // Apply EasyBreathe logic at the nightly level: if On, Rise Time becomes N/A
            if (weightedEasyBreathe === 'On') {
                weightedRiseTime = 'N/A';
            }
            
            nightlyData.push({
                date: sleepNightDate,
                startTime: sessions[0].time,
                duration: totalDuration,
                sessions: sessions.length,
                weightedGI: weightedGI,
                machineType: sessions[0].machineType || 'Unknown',
                ipap: weightedIPAP,
                epap: weightedEPAP,
                pressureSupport: pressureSupport,
                papMode: nightMode,
                riseTime: weightedRiseTime,
                trigger: weightedTrigger,
                cycle: weightedCycle,
                easyBreathe: weightedEasyBreathe
            });
    });
    
    return nightlyData.sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first
}

// Build and render heatmap for the most recent night by concatenating sessions
function renderMostRecentNightHeatmap(nightlyData) {
    if (!nightlyData || nightlyData.length === 0) return;
    
    // Most recent night is first due to sorting in groupByNight
    const mostRecentNightDate = nightlyData[0].date;
    const nightlyWeighted = nightlyData[0].weightedGI;
    
    // Collect sessions that belong to this sleep night
    const sessions = getSessionsForNight(mostRecentNightDate);
    if (!sessions || sessions.length === 0) return;
    
    // Sort by start time
    sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
    
    // Concatenate inspirations, adjusting sample indices
    let sampleOffset = 0;
    const concatenatedInspirations = [];
    sessions.forEach(session => {
        if (!session.inspirations || session.inspirations.length === 0) return;
        session.inspirations.forEach(insp => {
            concatenatedInspirations.push({
                start: (insp.start || 0) + sampleOffset,
                end: (insp.end || 0) + sampleOffset,
                indices: insp.indices
            });
        });
        // Advance offset by this session's length in samples
        const sessionSamples = session.sampleCount || (session.inspirations[session.inspirations.length - 1]?.end || 0);
        sampleOffset += sessionSamples;
    });
    
    // Prepare globals expected by original displayHeatMap()
    window.startDateTime = new Date(sessions[0].startDateTime);
    // Provide a placeholder dataArray so click detail handler is safe if used
    window.dataArray = new Float32Array(Math.max(sampleOffset, 1));
    
    // Use duration-weighted nightly components for the labels on the left
    const resultsForHeatmap = {
        inspirations: concatenatedInspirations,
        cumIndex: nightlyWeighted
    };
    
    try {
        displayHeatMap(resultsForHeatmap);
    } catch (e) {
        console.error('Heatmap render failed:', e);
    }
}

// Helper: find sessions in nightlyResults that map to the given sleep night date
function getSessionsForNight(sleepNightDate) {
    if (!nightlyResults || nightlyResults.length === 0) return [];
    
    const sessions = [];
    nightlyResults.forEach(result => {
        const sessionDateTime = new Date(result.startDateTime);
        const sessionHour = sessionDateTime.getHours();
        let nightDate;
        if (sessionHour >= 18) {
            nightDate = result.date;
        } else if (sessionHour < 12) {
            const prevDate = new Date(sessionDateTime);
            prevDate.setDate(prevDate.getDate() - 1);
            nightDate = prevDate.toISOString().split('T')[0];
        } else {
            nightDate = result.date;
        }
        if (nightDate === sleepNightDate) sessions.push(result);
    });
    return sessions;
}

// Populate night dropdown
function populateNightSelector(nightlyData) {
    const select = document.getElementById('nightSelect');
    if (!select) return;
    select.innerHTML = '';
    nightlyData.forEach(night => {
        const opt = document.createElement('option');
        opt.value = night.date;
        opt.textContent = night.date;
        select.appendChild(opt);
    });
    if (nightlyData.length > 0) {
        select.value = nightlyData[0].date; // most recent
    }
    // Enable/disable nav buttons
    updateNightNavButtons();
}

// Update heatmap when a different night is selected
function updateNightHeatmap() {
    const select = document.getElementById('nightSelect');
    if (!select || !window.originalNightlyData) return;
    const date = select.value;
    const night = window.originalNightlyData.find(n => n.date === date);
    if (!night) return;
    updateNightNavButtons();
    
    // Build concatenated inspirations and render just like in most-recent function
    const sessions = getSessionsForNight(date);
    if (!sessions || sessions.length === 0) return;
    sessions.sort((a, b) => new Date(a.startDateTime) - new Date(b.startDateTime));
    let sampleOffset = 0;
    const concatenatedInspirations = [];
    sessions.forEach(session => {
        if (!session.inspirations) return;
        session.inspirations.forEach(insp => {
            concatenatedInspirations.push({
                start: (insp.start || 0) + sampleOffset,
                end: (insp.end || 0) + sampleOffset,
                indices: insp.indices
            });
        });
        const sessionSamples = session.sampleCount || (session.inspirations[session.inspirations.length - 1]?.end || 0);
        sampleOffset += sessionSamples;
    });
    window.startDateTime = new Date(sessions[0].startDateTime);
    window.dataArray = new Float32Array(Math.max(sampleOffset, 1));
    try {
        displayHeatMap({ inspirations: concatenatedInspirations, cumIndex: night.weightedGI });
    } catch (e) {
        console.error('Heatmap render failed:', e);
    }
}

// Night navigation helpers
function prevNight(){
    const select = document.getElementById('nightSelect');
    if (!select) return;
    const idx = select.selectedIndex;
    if (idx < select.options.length - 1){
        select.selectedIndex = idx + 1; // list is most-recent first
        updateNightHeatmap();
    }
}

function nextNight(){
    const select = document.getElementById('nightSelect');
    if (!select) return;
    const idx = select.selectedIndex;
    if (idx > 0){
        select.selectedIndex = idx - 1;
        updateNightHeatmap();
    }
}

function updateNightNavButtons(){
    const select = document.getElementById('nightSelect');
    const prev = document.getElementById('nightPrev');
    const next = document.getElementById('nightNext');
    if (!select || !prev || !next) return;
    prev.disabled = (select.selectedIndex >= select.options.length - 1);
    next.disabled = (select.selectedIndex <= 0);
}

function updateSummaryCards(nightlyData) {
    document.getElementById('nightsCount').textContent = nightlyData.length;
    
    if (nightlyData.length > 0) {
        const avgOverall = nightlyData.reduce((sum, night) => sum + night.weightedGI.overall, 0) / nightlyData.length;
        const bestNight = Math.min(...nightlyData.map(night => night.weightedGI.overall));
        const worstNight = Math.max(...nightlyData.map(night => night.weightedGI.overall));
        
        document.getElementById('avgOverallGI').textContent = avgOverall.toFixed(2);
        document.getElementById('bestNightGI').textContent = bestNight.toFixed(2);
        document.getElementById('worstNightGI').textContent = worstNight.toFixed(2);
    }
}

function createTrendsChart(nightlyData) {
    window.originalNightlyData = nightlyData; // Store for filtering
    // Small delay to ensure DOM is ready and prevent resize loops
    setTimeout(() => {
        // Initialize custom date inputs to full span if empty
        const block = document.getElementById('customDateBlock');
        const startInput = document.getElementById('customStartDate');
        const endInput = document.getElementById('customEndDate');
        if (nightlyData && nightlyData.length > 0 && startInput && endInput) {
            const dates = nightlyData.map(n => new Date(n.date)).sort((a,b)=>a-b);
            const min = dates[0];
            const max = dates[dates.length-1];
            if (!startInput.value) startInput.value = formatDateISO(min);
            if (!endInput.value) endInput.value = formatDateISO(max);
            startInput.max = formatDateISO(max);
            endInput.min = formatDateISO(min);
        }
        updateTrendsChart();
    }, 100);
}

function updateAllCharts() {
    updateTrendsChart();
    updateComponentsChart();
}

function updateTrendsChart() {
    const ctx = document.getElementById('trendsChart').getContext('2d');
    
    if (trendsChart) {
        trendsChart.destroy();
    }
    
    // Get filter settings
    const dateRange = document.getElementById('dateRangeSelect').value;
    const smoothing = document.getElementById('smoothingSelect').value;
    
    // Filter data by date range
    let filteredData = filterByDateRange(window.originalNightlyData, dateRange);
    
    // Optionally hide nights with <4 hours duration
    const hideShort = document.getElementById('hideShortNights')?.checked;
    if (hideShort) {
        filteredData = filteredData.filter(n => (n.duration || 0) >= 4.0);
    }
    
    // Sort chronologically for proper trend visualization
    filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // Apply smoothing
    const smoothedData = applySmoothing(filteredData, smoothing);
    
    const labels = smoothedData.map(night => night.date);
    const overallData = smoothedData.map(night => night.weightedGI.overall);
    
    // Calculate trend line
    const trendLine = calculateLinearTrend(overallData);
    
    // Create datasets
    const datasets = [{
        label: 'Overall Glasgow Index',
        data: overallData,
        borderColor: '#007bff',
        backgroundColor: 'rgba(0, 123, 255, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.2,
        pointRadius: 5,
        pointHoverRadius: 8
    }];
    
    // Add trend line
    if (smoothedData.length > 2) {
        datasets.push({
            label: 'Trend Line',
            data: trendLine,
            borderColor: '#dc3545',
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: [5, 5],
            fill: false,
            pointRadius: 0,
            tension: 0
        });
    }
    
    // Calculate smart Y-axis scaling
    const maxGI = Math.max(...overallData);
    const minGI = Math.min(...overallData);
    const dataRange = maxGI - minGI;
    
    // Smart scaling based on data range
    let yMax;
    if (maxGI <= 0.5) {
        yMax = Math.ceil(maxGI * 10) / 10 + 0.1; // Round up to nearest 0.1 + buffer
    } else if (maxGI <= 1.0) {
        yMax = Math.ceil(maxGI * 4) / 4 + 0.25; // Round up to nearest 0.25 + buffer
    } else if (maxGI <= 2.0) {
        yMax = Math.ceil(maxGI * 2) / 2 + 0.5; // Round up to nearest 0.5 + buffer
    } else if (maxGI <= 4.0) {
        yMax = Math.ceil(maxGI) + 1; // Round up to nearest integer + buffer
    } else {
        yMax = Math.ceil(maxGI * 1.25); // 25% buffer for high values
    }
    
    // Ensure minimum range for visual clarity
    if (dataRange < 0.2 && maxGI < 2.0) {
        yMax = Math.max(yMax, maxGI + 0.3);
    }
    
    trendsChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            resizeDelay: 0,
            animation: {
                duration: 0
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    title: {
                        display: true,
                        text: 'Glasgow Index',
                        font: { size: 14, weight: 'bold' }
                    },
                    ticks: {
                        callback: function(value) {
                            // Dynamic precision based on range
                            if (yMax <= 1.0) {
                                return value.toFixed(2);
                            } else if (yMax <= 3.0) {
                                return value.toFixed(1);
                            } else {
                                return value.toFixed(0);
                            }
                        },
                        stepSize: function() {
                            // Dynamic step size based on range
                            if (yMax <= 0.5) return 0.1;
                            if (yMax <= 1.0) return 0.2;
                            if (yMax <= 2.0) return 0.5;
                            if (yMax <= 5.0) return 1.0;
                            return 2.0;
                        }()
                    },
                    grid: {
                        color: function(context) {
                            // Color-code quality zones
                            const value = context.tick.value;
                            if (value <= 0.2) return 'rgba(40, 167, 69, 0.2)'; // Excellent
                            if (value <= 1.0) return 'rgba(23, 162, 184, 0.2)'; // Good
                            if (value <= 2.0) return 'rgba(255, 193, 7, 0.2)'; // Fair
                            if (value <= 3.0) return 'rgba(220, 53, 69, 0.2)'; // Poor
                            return 'rgba(108, 117, 125, 0.2)'; // Very Poor
                        }
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Date',
                        font: { size: 14, weight: 'bold' }
                    },
                    ticks: {
                        maxTicksLimit: 12,
                        callback: function(value, index) {
                            const date = new Date(this.getLabelForValue(value));
                            return date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric' 
                            });
                        }
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Glasgow Index Trend ${getDateRangeTitle(dateRange)} ${getSmoothingTitle(smoothing)}`,
                    font: { size: 16, weight: 'bold' }
                },
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return `Night: ${context[0].label}`;
                        },
                        afterLabel: function(context) {
                            const gi = context.parsed.y;
                            let quality = 'Very Poor';
                            if (gi <= 0.2) quality = 'Excellent';
                            else if (gi <= 1.0) quality = 'Good';
                            else if (gi <= 2.0) quality = 'Fair';
                            else if (gi <= 3.0) quality = 'Poor';
                            
                            return `Quality: ${quality}`;
                        }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function createComponentsChart(nightlyData) {
    window.originalComponentData = nightlyData; // Store for filtering
    // Small delay to ensure DOM is ready and prevent resize loops
    setTimeout(() => {
        updateComponentsChart();
    }, 100);
}

function updateComponentsChart() {
    const ctx = document.getElementById('componentsChart').getContext('2d');
    
    if (componentsChart) {
        componentsChart.destroy();
    }
    
    // Get settings
    const showTrendLines = document.getElementById('showTrendLines').checked;
    
    // Apply same filtering as trends chart
    const dateRange = document.getElementById('dateRangeSelect').value;
    const smoothing = document.getElementById('smoothingSelect').value;
    
    // Filter data by date range
    let filteredData = filterByDateRange(window.originalComponentData, dateRange);
    
    // Optionally hide nights with <4 hours duration
    const hideShort = document.getElementById('hideShortNights')?.checked;
    if (hideShort) {
        filteredData = filteredData.filter(n => (n.duration || 0) >= 4.0);
    }
    
    // Sort chronologically for proper trend visualization
    filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // Apply smoothing
    const nightlyData = applySmoothing(filteredData, smoothing);
    const labels = nightlyData.map(night => night.date);
    const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
    const colors = [
        '#FF6384', '#36A2EB', '#FFCE56', '#2ECC71', '#9966FF',
        '#FF9F40', '#8B4513', '#C9CBCF', '#000000'
    ];
    
    const datasets = [];
    
    components.forEach((component, index) => {
        // Check if this component is selected for display
        const compCheckbox = document.getElementById(`comp_${component}`);
        const isSelected = compCheckbox ? compCheckbox.checked : true; // Default to true if checkbox doesn't exist
        if (!isSelected) return;
        
        let data = nightlyData.map(night => night.weightedGI[component]);
        
        const dataset = {
            label: formatComponentName(component),
            data: data,
            borderColor: colors[index],
            backgroundColor: colors[index] + '30',
            borderWidth: 2.5,
            fill: false,
            tension: 0.1,
            pointRadius: 4,
            pointHoverRadius: 7,
            pointBackgroundColor: colors[index],
            pointBorderColor: '#fff',
            pointBorderWidth: 2
        };
        
        datasets.push(dataset);
        
        // Add trend lines if requested
        if (showTrendLines && data.length > 2) {
            const trendData = calculateLinearTrend(data);
            datasets.push({
                label: `${formatComponentName(component)} Trend`,
                data: trendData,
                borderColor: colors[index],
                backgroundColor: 'transparent',
                borderWidth: 1.5,
                borderDash: [3, 3],
                fill: false,
                pointRadius: 0,
                tension: 0,
                hidden: false // Show in legend but less prominent
            });
        }
    });
    
    const yAxisTitle = 'Component Index Value';
    const yAxisMax = undefined;
    
    componentsChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            resizeDelay: 0,
            animation: {
                duration: 0
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yAxisMax,
                    title: {
                        display: true,
                        text: yAxisTitle,
                        font: { size: 14, weight: 'bold' }
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1);
                        }
                    },
                    grid: {
                        color: 'rgba(0,0,0,0.1)'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Date',
                        font: { size: 14, weight: 'bold' }
                    },
                    ticks: {
                        maxTicksLimit: 12,
                        callback: function(value, index) {
                            const date = new Date(this.getLabelForValue(value));
                            return date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric' 
                            });
                        }
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Glasgow Index Components Over Time ${getDateRangeTitle(dateRange)} ${getSmoothingTitle(smoothing)}`,
                    font: { size: 16, weight: 'bold' }
                },
                legend: {
                    display: true,
                    position: 'right',
                    labels: {
                        filter: function(legendItem, chartData) {
                            // Hide trend line entries from legend for cleaner display
                            return !legendItem.text.includes('Trend');
                        },
                        usePointStyle: true,
                        padding: 15
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return `Night: ${context[0].label}`;
                        },
                        label: function(context) {
                            const value = context.parsed.y.toFixed(2);
                            return `${context.dataset.label}: ${value}`;
                        }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function createResultsTable(nightlyData) {
    const tbody = document.getElementById('resultsTableBody');
    tbody.innerHTML = '';
    
    nightlyData.forEach(night => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
            <td>${night.date}</td>
            <td>${night.startTime}</td>
            <td>${night.duration.toFixed(1)}</td>
            <td>${night.machineType}</td>
            <td><span class="gi-value ${getGIClass(night.weightedGI.overall)}">${night.weightedGI.overall.toFixed(2)}</span></td>
            <td>${night.weightedGI.skew.toFixed(2)}</td>
            <td>${night.weightedGI.spike.toFixed(2)}</td>
            <td>${night.weightedGI.flatTop.toFixed(2)}</td>
            <td>${night.weightedGI.topHeavy.toFixed(2)}</td>
            <td>${night.weightedGI.multiPeak.toFixed(2)}</td>
            <td>${night.weightedGI.noPause.toFixed(2)}</td>
            <td>${night.weightedGI.inspirRate.toFixed(2)}</td>
            <td>${night.weightedGI.multiBreath.toFixed(2)}</td>
            <td>${night.weightedGI.ampVar.toFixed(2)}</td>
            <td>${night.ipap !== 'N/A' ? night.ipap : 'N/A'}</td>
            <td>${night.epap !== 'N/A' ? night.epap : 'N/A'}</td>
            <td>${night.pressureSupport !== 'N/A' ? night.pressureSupport : 'N/A'}</td>
            <td>${night.easyBreathe !== 'N/A' ? night.easyBreathe : 'N/A'}</td>
            <td>${night.riseTime !== 'N/A' ? night.riseTime : 'N/A'}</td>
            <td>${night.trigger !== 'N/A' ? sensitivityLabelFromValue(night.trigger) : 'N/A'}</td>
            <td>${night.cycle !== 'N/A' ? sensitivityLabelFromValue(night.cycle) : 'N/A'}</td>
        `;
        
        tbody.appendChild(row);
    });
}

function formatComponentName(component) {
    const names = {
        skew: 'Skew',
        spike: 'Spike',
        flatTop: 'Flat Top',
        topHeavy: 'Top Heavy',
        multiPeak: 'Multi Peak',
        noPause: 'No Pause',
        inspirRate: 'Inspir Rate',
        multiBreath: 'Multi Breath',
        ampVar: 'Variable Amp'
    };
    return names[component] || component;
}

function getGIClass(value) {
    if (value <= 0.2) return 'gi-excellent';
    if (value <= 1.0) return 'gi-good';
    if (value <= 2.0) return 'gi-fair';
    if (value <= 3.0) return 'gi-poor';
    return 'gi-very-poor';
}

// Utility functions for enhanced charting

function filterByDateRange(data, range) {
    if (range === 'all') return data;
    if (range === 'custom') {
        const s = document.getElementById('customStartDate')?.value;
        const e = document.getElementById('customEndDate')?.value;
        if (!s || !e) return data;
        const start = new Date(s);
        const end = new Date(e);
        // Include entire end day
        end.setHours(23,59,59,999);
        return data.filter(night => new Date(night.date) >= start && new Date(night.date) <= end);
    }
    
    const days = parseInt(range);
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return data.filter(night => new Date(night.date) >= cutoffDate);
}

function applySmoothing(data, smoothing) {
    if (smoothing === 'none' || data.length < 3) return data;
    
    const window = parseInt(smoothing);
    const smoothedData = [];
    
    for (let i = 0; i < data.length; i++) {
        const start = Math.max(0, i - Math.floor(window / 2));
        const end = Math.min(data.length, i + Math.ceil(window / 2));
        
        const windowData = data.slice(start, end);
        const avgGI = {};
        
        // Calculate average for each component
        Object.keys(data[0].weightedGI).forEach(component => {
            avgGI[component] = windowData.reduce((sum, night) => 
                sum + night.weightedGI[component], 0) / windowData.length;
            avgGI[component] = Math.round(avgGI[component] * 100) / 100;
        });
        
        smoothedData.push({
            ...data[i],
            weightedGI: avgGI
        });
    }
    
    return smoothedData;
}

function calculateLinearTrend(data) {
    if (data.length < 2) return data;
    
    const n = data.length;
    const x = Array.from({length: n}, (_, i) => i);
    const y = data;
    
    // Calculate linear regression
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    return x.map(xi => slope * xi + intercept);
}

function filterOutliers(data) {
    if (data.length < 4) return data;
    
    // Calculate Q1, Q3, and IQR
    const sorted = [...data].sort((a, b) => a - b);
    const q1Index = Math.floor(sorted.length * 0.25);
    const q3Index = Math.floor(sorted.length * 0.75);
    const q1 = sorted[q1Index];
    const q3 = sorted[q3Index];
    const iqr = q3 - q1;
    
    const lowerBound = q1 - 1.5 * iqr;
    const upperBound = q3 + 1.5 * iqr;
    
    // Replace outliers with median
    const median = sorted[Math.floor(sorted.length / 2)];
    
    return data.map(value => {
        if (value < lowerBound || value > upperBound) {
            return median;
        }
        return value;
    });
}

function getDateRangeTitle(range) {
    if (range === 'custom') {
        const s = document.getElementById('customStartDate')?.value;
        const e = document.getElementById('customEndDate')?.value;
        if (s && e) {
            return `(Custom: ${formatDateLabel(new Date(s))} to ${formatDateLabel(new Date(e))})`;
        }
        return '(Custom)';
    }
    switch(range) {
        case '30': return '(Last 30 Days)';
        case '60': return '(Last 60 Days)';
        case '90': return '(Last 90 Days)';
        default: return '';
    }
}

function getSmoothingTitle(smoothing) {
    switch(smoothing) {
        case '3': return '- 3-day Moving Average';
        case '7': return '- 7-day Moving Average';
        case '14': return '- 14-day Moving Average';
        default: return '';
    }
}

// Helpers for custom date handling
function formatDateISO(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

function formatDateLabel(d) {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function onDateRangeChange() {
    const range = document.getElementById('dateRangeSelect').value;
    const block = document.getElementById('customDateBlock');
    if (range === 'custom') {
        block.style.display = '';
    } else {
        block.style.display = 'none';
    }
}

// Component filtering functions

function selectAllComponents() {
    const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
    components.forEach(comp => {
        const checkbox = document.getElementById(`comp_${comp}`);
        if (checkbox) checkbox.checked = true;
    });
    updateComponentsChart();
}

function selectNoComponents() {
    const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
    components.forEach(comp => {
        const checkbox = document.getElementById(`comp_${comp}`);
        if (checkbox) checkbox.checked = false;
    });
    updateComponentsChart();
}

function selectMainComponents() {
    // First uncheck all
    selectNoComponents();
    
    // Get filtered data to calculate averages
    const dateRange = document.getElementById('dateRangeSelect').value;
    let filteredData = filterByDateRange(window.originalComponentData, dateRange);
    
    if (filteredData.length === 0) return;
    
    // Calculate average values for each component over the filtered period
    const components = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak', 'noPause', 'inspirRate', 'multiBreath', 'ampVar'];
    const componentAverages = [];
    
    components.forEach(comp => {
        const avgValue = filteredData.reduce((sum, night) => sum + night.weightedGI[comp], 0) / filteredData.length;
        componentAverages.push({ component: comp, average: avgValue });
    });
    
    // Sort by average value (highest first) and take top 4
    componentAverages.sort((a, b) => b.average - a.average);
    const topComponents = componentAverages.slice(0, 4).map(item => item.component);
    
    // Select the top 4 components
    topComponents.forEach(comp => {
        const checkbox = document.getElementById(`comp_${comp}`);
        if (checkbox) checkbox.checked = true;
    });
    
    updateComponentsChart();
}

function selectFlowComponents() {
    // First uncheck all
    selectNoComponents();
    
    // Select components related to inspiration flow shape
    const flowComponents = ['skew', 'spike', 'flatTop', 'topHeavy', 'multiPeak'];
    flowComponents.forEach(comp => {
        const checkbox = document.getElementById(`comp_${comp}`);
        if (checkbox) checkbox.checked = true;
    });
    updateComponentsChart();
}

function selectTimingComponents() {
    // First uncheck all
    selectNoComponents();
    
    // Select components related to breathing timing and rhythm
    const timingComponents = ['noPause', 'inspirRate', 'multiBreath', 'ampVar'];
    timingComponents.forEach(comp => {
        const checkbox = document.getElementById(`comp_${comp}`);
        if (checkbox) checkbox.checked = true;
    });
    updateComponentsChart();
}

// STR file parsing for pressure settings
async function parseSTRFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const arrayBuffer = event.target.result;
                const fileData = parseEDFFile(arrayBuffer);
                
                if (fileData.formatVersion !== "0") {
                    throw new Error("Incorrect STR file format");
                }
                
                // Extract pressure and mode data from STR file
                const pressureData = extractPressureFromSTR(fileData);
                resolve(pressureData);
            } catch (error) {
                reject(new Error(`Failed to parse STR file: ${error.message}`));
            }
        };
        
        reader.onerror = function() {
            reject(new Error(`Failed to read STR file ${file.name}`));
        };
        
        reader.readAsArrayBuffer(file);
    });
}

function extractPressureFromSTR(fileData) {
    // Extract pressure, mode, and key machine settings from STR file signals
    const pressureData = {
        dailyData: {},  // Date -> {ipap, epap, mode, riseTime, trigger, cycle, easyBreathe}
        defaultMode: 'Unknown'
    };
    
    if (!fileData.signals) {
        console.log('No signals found in STR file');
        return pressureData;
    }
    
    // Use the file start date as a reference point for date conversion
    const fileStartDate = fileData.startDateTime;
    console.log('STR file start date:', fileStartDate);
    
    console.log('=== STR File Signal Analysis ===');
    fileData.signals.forEach((signal, index) => {
        console.log(`Signal ${index}: "${signal.label}" (${signal.physDimension}) - ${signal.physicalValues ? signal.physicalValues.length : 0} samples`);
    });
    
    // Find key signals for pressure, mode, and additional settings
    const targetIPAPSignal = fileData.signals.find(s => s.label && s.label.includes('TgtIPAP.50'));
    const targetEPAPSignal = fileData.signals.find(s => s.label && s.label.includes('TgtEPAP.50'));
    const modeSignal = fileData.signals.find(s => s.label && s.label.includes('Mode'));
    const dateSignal = fileData.signals.find(s => s.label && s.label.includes('Date'));
    // Additional BiPAP settings
    const riseTimeSignal = fileData.signals.find(s => s.label && s.label.includes('S.RiseTime'));
    const triggerSignal = fileData.signals.find(s => s.label && s.label.includes('S.Trigger'));
    const cycleSignal = fileData.signals.find(s => s.label && s.label.includes('S.Cycle'));
    const easyBreatheSignal = fileData.signals.find(s => s.label && s.label.includes('S.EasyBreathe'));
    
    // Look for EPR-related signals for AirSense machines
    const eprLevelSignal = fileData.signals.find(s => s.label && s.label.includes('S.EPR.Level'));
    const eprEnableSignal = fileData.signals.find(s => s.label && s.label.includes('S.EPR.EPREnable'));
    const cpapPressSignal = fileData.signals.find(s => s.label && s.label.includes('S.C.Press'));
    
    // Check for AirSense-specific signals (CPAP pressure + EPR)
    const hasEPR = eprLevelSignal && eprEnableSignal;
    const hasCPAPPress = cpapPressSignal;
    
    console.log('Found signals:', {
        ipap: targetIPAPSignal ? targetIPAPSignal.label : 'Not found',
        epap: targetEPAPSignal ? targetEPAPSignal.label : 'Not found',
        mode: modeSignal ? modeSignal.label : 'Not found',
        date: dateSignal ? dateSignal.label : 'Not found',
        eprLevel: eprLevelSignal ? eprLevelSignal.label : 'Not found',
        eprEnable: eprEnableSignal ? eprEnableSignal.label : 'Not found',
        cpapPress: cpapPressSignal ? cpapPressSignal.label : 'Not found',
        riseTime: riseTimeSignal ? riseTimeSignal.label : 'Not found',
        trigger: triggerSignal ? triggerSignal.label : 'Not found',
        cycle: cycleSignal ? cycleSignal.label : 'Not found',
        easyBreathe: easyBreatheSignal ? easyBreatheSignal.label : 'Not found'
    });
    
    console.log('Machine type analysis:', {
        hasEPR: hasEPR,
        hasCPAPPress: hasCPAPPress,
        hasIPAPEPAP: !!(targetIPAPSignal && targetEPAPSignal)
    });
    
    // Debug signal properties
    if (targetIPAPSignal) {
        console.log('IPAP Signal Properties:', {
            label: targetIPAPSignal.label,
            physDimension: targetIPAPSignal.physDimension,
            physMin: targetIPAPSignal.physMin,
            physMax: targetIPAPSignal.physMax,
            digMin: targetIPAPSignal.digMin,
            digMax: targetIPAPSignal.digMax,
            physFactor: targetIPAPSignal.physFactor,
            hasPhysicalValues: !!(targetIPAPSignal.physicalValues && targetIPAPSignal.physicalValues.length),
            hasDigitalValues: !!(targetIPAPSignal.digitalValues && targetIPAPSignal.digitalValues.length)
        });
    }
    
    if (targetEPAPSignal) {
        console.log('EPAP Signal Properties:', {
            label: targetEPAPSignal.label,
            physDimension: targetEPAPSignal.physDimension,
            physMin: targetEPAPSignal.physMin,
            physMax: targetEPAPSignal.physMax,
            digMin: targetEPAPSignal.digMin,
            digMax: targetEPAPSignal.digMax,
            physFactor: targetEPAPSignal.physFactor,
            hasPhysicalValues: !!(targetEPAPSignal.physicalValues && targetEPAPSignal.physicalValues.length),
            hasDigitalValues: !!(targetEPAPSignal.digitalValues && targetEPAPSignal.digitalValues.length)
        });
    }
    
    // Determine if this is an AirSense (CPAP+EPR) or AirCurve (BiPAP) machine
    const isAirSenseMode = hasCPAPPress && hasEPR && !targetIPAPSignal;
    const isAirCurveMode = targetIPAPSignal && targetEPAPSignal;
    
    console.log('Machine mode detection:', {
        isAirSenseMode: isAirSenseMode,
        isAirCurveMode: isAirCurveMode
    });
    
    if (!dateSignal) {
        console.log('Date signal not found in STR file');
        return pressureData;
    }
    
    if (!isAirSenseMode && !isAirCurveMode) {
        console.log('Could not determine machine type - neither AirSense nor AirCurve signals found');
        return pressureData;
    }
    
    // Extract daily pressure data
    const dates = dateSignal.physicalValues || dateSignal.digitalValues || [];
    
    // For pressure signals, we need to properly convert digital to physical values
    let ipapValues = [];
    let epapValues = [];
    
    if (isAirCurveMode) {
        console.log('Processing AirCurve/BiPAP pressure data...');
        // AirCurve machines have separate IPAP and EPAP settings
        
        // IPAP signals should already be in cmH2O units!
        // The EDF parser is incorrectly applying pressure scaling to signals already in physical units
        if (targetIPAPSignal.physicalValues && targetIPAPSignal.physicalValues.length > 0) {
        console.log('IPAP Signal is labeled as (cmH2O) - should already be in correct units!');
        console.log('Signal properties:', {
            physMin: targetIPAPSignal.physMin,
            physMax: targetIPAPSignal.physMax,
            digMin: targetIPAPSignal.digMin,
            digMax: targetIPAPSignal.digMax,
            physFactor: targetIPAPSignal.physFactor
        });
        
        // Try using the digital values directly with proper scaling
        if (targetIPAPSignal.digitalValues && targetIPAPSignal.digitalValues.length > 0) {
            console.log('Using digital values and calculating proper physical values');
            ipapValues = targetIPAPSignal.digitalValues.map((digitalVal, index) => {
                // Calculate proper physical value using signal min/max ranges
                const physMin = parseFloat(targetIPAPSignal.physMin);
                const physMax = parseFloat(targetIPAPSignal.physMax);
                const digMin = parseInt(targetIPAPSignal.digMin);
                const digMax = parseInt(targetIPAPSignal.digMax);
                
                // Linear scaling: physical = physMin + (digital - digMin) * (physMax - physMin) / (digMax - digMin)
                const physicalValue = physMin + (digitalVal - digMin) * (physMax - physMin) / (digMax - digMin);
                const rounded = Math.round(physicalValue * 5) / 5; // Round to nearest 0.2
                
                if (index < 5) {
                    console.log(`IPAP[${index}]: Digital ${digitalVal} ‚Üí Physical ${physicalValue.toFixed(3)} ‚Üí ${rounded} cmH2O`);
                }
                
                return rounded;
            });
        } else {
            console.log('Falling back to pre-converted values (likely incorrect due to double scaling)');
            ipapValues = targetIPAPSignal.physicalValues.map(val => {
                const value = parseFloat(val);
                return Math.round(value * 5) / 5;
            });
        }
        console.log('Using pre-converted IPAP physical values with scaling correction (√∑50)');
        console.log('Sample IPAP values (raw):', targetIPAPSignal.physicalValues.slice(0, 5));
        console.log('Sample IPAP values (corrected):', ipapValues.slice(0, 5));
    } else if (targetIPAPSignal.digitalValues && targetIPAPSignal.physFactor) {
        // Convert digital to physical using the scaling factor and apply correction
        ipapValues = targetIPAPSignal.digitalValues.map(digital => {
            const physicalValue = digital * targetIPAPSignal.physFactor;
            const correctedValue = physicalValue / 50.0; // Apply scaling correction
            return Math.round(correctedValue * 20) / 20; // Round to nearest 0.05 for better precision
        });
        console.log('Converting IPAP digital to physical with scaling correction');
        console.log('Factor:', targetIPAPSignal.physFactor, 'with √∑50 correction');
        console.log('Sample IPAP conversion:', targetIPAPSignal.digitalValues.slice(0, 3), '->', ipapValues.slice(0, 3));
    }
    
    // Convert EPAP values - physicalValues are already converted and stored as strings
    if (targetEPAPSignal.physicalValues && targetEPAPSignal.physicalValues.length > 0) {
        // Convert string values to numbers and apply scaling correction
        // STR file pressure values appear to be scaled by factor of ~50  
        // Apply same precision approach as IPAP
        // EPAP signals should already be in cmH2O units!
        console.log('EPAP Signal is labeled as (cmH2O) - should already be in correct units!');
        
        // Try using the digital values directly with proper scaling
        if (targetEPAPSignal.digitalValues && targetEPAPSignal.digitalValues.length > 0) {
            console.log('Using digital values and calculating proper physical values for EPAP');
            epapValues = targetEPAPSignal.digitalValues.map((digitalVal, index) => {
                // Calculate proper physical value using signal min/max ranges
                const physMin = parseFloat(targetEPAPSignal.physMin);
                const physMax = parseFloat(targetEPAPSignal.physMax);
                const digMin = parseInt(targetEPAPSignal.digMin);
                const digMax = parseInt(targetEPAPSignal.digMax);
                
                // Linear scaling: physical = physMin + (digital - digMin) * (physMax - physMin) / (digMax - digMin)
                const physicalValue = physMin + (digitalVal - digMin) * (physMax - physMin) / (digMax - digMin);
                const rounded = Math.round(physicalValue * 5) / 5; // Round to nearest 0.2
                
                if (index < 5) {
                    console.log(`EPAP[${index}]: Digital ${digitalVal} ‚Üí Physical ${physicalValue.toFixed(3)} ‚Üí ${rounded} cmH2O`);
                }
                
                return rounded;
            });
        } else {
            console.log('Falling back to pre-converted values (likely incorrect due to double scaling)');
            epapValues = targetEPAPSignal.physicalValues.map(val => {
                const value = parseFloat(val);
                return Math.round(value * 5) / 5;
            });
        }
        console.log('Using pre-converted EPAP physical values with scaling correction');
        console.log('Sample EPAP values (raw):', targetEPAPSignal.physicalValues.slice(0, 5));
        console.log('Sample EPAP values (corrected):', epapValues.slice(0, 5));
    } else if (targetEPAPSignal.digitalValues && targetEPAPSignal.physFactor) {
        // Convert digital to physical using the scaling factor and apply correction
        epapValues = targetEPAPSignal.digitalValues.map(digital => {
            const physicalValue = digital * targetEPAPSignal.physFactor;
            const correctedValue = physicalValue / 50.0; // Apply scaling correction
            return Math.round(correctedValue * 20) / 20; // Round to nearest 0.05 for better precision
        });
        console.log('Converting EPAP digital to physical with scaling correction');
        console.log('Factor:', targetEPAPSignal.physFactor, 'with √∑50 correction');
        console.log('Sample EPAP conversion:', targetEPAPSignal.digitalValues.slice(0, 3), '->', epapValues.slice(0, 3));
        }
        
    } else if (isAirSenseMode) {
        console.log('Processing AirSense/CPAP+EPR pressure data...');
        // AirSense machines use CPAP pressure + EPR (Expiratory Pressure Relief)
        // IPAP = CPAP Pressure, EPAP = CPAP Pressure - EPR Level
        
        // Get CPAP pressure values
        let cpapPressValues = [];
        if (cpapPressSignal.physicalValues && cpapPressSignal.physicalValues.length > 0) {
            cpapPressValues = cpapPressSignal.physicalValues.map(val => {
                const rawValue = parseFloat(val);
                const correctedValue = rawValue / 50.0; // Apply same scaling correction
                return Math.round(correctedValue * 10) / 10;
            });
            console.log('CPAP pressure values (corrected):', cpapPressValues.slice(0, 5));
        }
        
        // Get EPR level values
        let eprLevelValues = [];
        if (eprLevelSignal.physicalValues && eprLevelSignal.physicalValues.length > 0) {
            eprLevelValues = eprLevelSignal.physicalValues.map(val => {
                const rawValue = parseFloat(val);
                // EPR is typically 0-5 cmH2O, might not need scaling correction
                return Math.round(rawValue * 10) / 10;
            });
            console.log('EPR level values:', eprLevelValues.slice(0, 5));
        }
        
        // Check EPR enable status
        let eprEnableValues = [];
        if (eprEnableSignal.physicalValues && eprEnableSignal.physicalValues.length > 0) {
            eprEnableValues = eprEnableSignal.physicalValues.map(val => parseInt(val));
        } else if (eprEnableSignal.digitalValues && eprEnableSignal.digitalValues.length > 0) {
            eprEnableValues = eprEnableSignal.digitalValues.map(val => parseInt(val));
        }
        
        // Calculate IPAP and EPAP for AirSense
        ipapValues = cpapPressValues; // IPAP = CPAP pressure
        epapValues = cpapPressValues.map((cpapPress, index) => {
            const eprLevel = eprLevelValues[index] || 0;
            const eprEnabled = eprEnableValues[index] || 0;
            
            if (eprEnabled && eprLevel > 0) {
                // EPAP = CPAP Pressure - EPR Level (when EPR is enabled)
                const epap = cpapPress - eprLevel;
                console.log(`EPAP[${index}]: ${cpapPress} - ${eprLevel} = ${epap} (EPR enabled)`);
                return Math.round(epap * 10) / 10;
            } else {
                // EPAP = CPAP Pressure (when EPR is disabled)
                console.log(`EPAP[${index}]: ${cpapPress} (EPR disabled)`);
                return cpapPress;
            }
        });
        
        console.log('AirSense calculated values:');
        console.log('IPAP (CPAP pressure):', ipapValues.slice(0, 5));
        console.log('EPAP (CPAP - EPR):', epapValues.slice(0, 5));
    }
    const modeValues = modeSignal ? (modeSignal.physicalValues || modeSignal.digitalValues || []) : [];
    const riseTimeValues = riseTimeSignal ? (riseTimeSignal.physicalValues || riseTimeSignal.digitalValues || []) : [];
    const triggerValues = triggerSignal ? (triggerSignal.physicalValues || triggerSignal.digitalValues || []) : [];
    const cycleValues = cycleSignal ? (cycleSignal.physicalValues || cycleSignal.digitalValues || []) : [];
    const easyBreatheValuesRaw = easyBreatheSignal ? (easyBreatheSignal.physicalValues || easyBreatheSignal.digitalValues || []) : [];
    // Normalize EasyBreathe values into 'On'/'Off'
    const easyBreatheValues = easyBreatheValuesRaw.map(v => (parseInt(v) ? 'On' : 'Off'));
    
    console.log('Data arrays lengths:', {
        dates: dates.length,
        ipap: ipapValues.length,
        epap: epapValues.length,
        mode: modeValues.length,
        riseTime: riseTimeValues.length,
        trigger: triggerValues.length,
        cycle: cycleValues.length,
        easyBreathe: easyBreatheValues.length
    });
    
    // Debug: Show first few date values to understand the format
    console.log('Sample date values:', dates.slice(0, 5));
    console.log('Sample IPAP values:', ipapValues.slice(0, 5));
    console.log('Sample EPAP values:', epapValues.slice(0, 5));
    
    for (let i = 0; i < Math.min(dates.length, ipapValues.length, epapValues.length); i++) {
        const dateValue = dates[i];
        const ipapValue = parseFloat(ipapValues[i]);
        const epapValue = parseFloat(epapValues[i]);
        let modeValue = modeValues.length > i ? modeValues[i] : 0;
        let riseTimeValue = riseTimeValues.length > i ? riseTimeValues[i] : undefined;
        const triggerValue = triggerValues.length > i ? triggerValues[i] : undefined;
        const cycleValue = cycleValues.length > i ? cycleValues[i] : undefined;
        const easyBreatheValue = easyBreatheValues.length > i ? easyBreatheValues[i] : undefined;
        
        // Convert date from various possible formats
        let dateStr = '';
        if (typeof dateValue === 'string' && dateValue.includes('-')) {
            dateStr = dateValue;
        } else if (typeof dateValue === 'number' || !isNaN(dateValue)) {
            // Convert from ResMed date format using the file start date as reference
            const dateNum = parseInt(dateValue);
            
            if (i === 0) {
                console.log(`Processing dates - First value: ${dateNum}, File start: ${fileStartDate}`);
            }
            
            // Use the file start date as the anchor point for the first date entry
            if (fileStartDate && i === 0) {
                // Assume the first date entry corresponds to the file start date
                dateStr = fileStartDate.toISOString().split('T')[0];
                window.strDateAnchor = {
                    firstDateNum: dateNum,
                    firstDateStr: dateStr
                };
                console.log(`Setting date anchor: ${dateNum} -> ${dateStr}`);
            } else if (window.strDateAnchor) {
                // Calculate subsequent dates based on the offset from the first date
                const daysDifference = dateNum - window.strDateAnchor.firstDateNum;
                const anchorDate = new Date(window.strDateAnchor.firstDateStr);
                const calculatedDate = new Date(anchorDate.getTime() + daysDifference * 24 * 60 * 60 * 1000);
                dateStr = calculatedDate.toISOString().split('T')[0];
            }
            
            if (i < 5) {
                console.log(`Date[${i}]: ${dateNum} -> ${dateStr}`);
            }
        }
        
        // Convert mode number to text
        let modeText = convertModeNumberToText(parseInt(modeValue));
        // Normalize additional settings to readable forms
        // If EasyBreathe is On, force rise time to undefined (to be rendered as N/A)
        if (easyBreatheValue === 'On') {
            riseTimeValue = undefined;
        }
        const riseTimeOut = riseTimeValue !== undefined ? parseFloat(riseTimeValue) : undefined;
        const triggerOut = triggerValue !== undefined ? parseInt(triggerValue) : undefined;
        const cycleOut = cycleValue !== undefined ? parseInt(cycleValue) : undefined;
        const easyBreatheOut = easyBreatheValue !== undefined ? easyBreatheValue : undefined;
        
        if (dateStr && !isNaN(ipapValue) && !isNaN(epapValue) && ipapValue > 0 && epapValue > 0) {
            pressureData.dailyData[dateStr] = {
                ipap: Math.round(ipapValue * 10) / 10,
                epap: Math.round(epapValue * 10) / 10,
                mode: modeText,
                riseTime: riseTimeOut,
                trigger: triggerOut,
                cycle: cycleOut,
                easyBreathe: easyBreatheOut
            };
            
            // Set default mode from first valid entry
            if (pressureData.defaultMode === 'Unknown') {
                pressureData.defaultMode = modeText;
            }
        }
    }
    
    console.log('Extracted pressure data:', pressureData);
    return pressureData;
}

function convertModeNumberToText(modeNum) {
    // Convert ResMed mode numbers to text
    const modeMap = {
        0: 'CPAP',
        1: 'APAP',
        2: 'AutoSet',  // ResMed's APAP
        3: 'APAP',
        4: 'BiPAP',
        5: 'BiPAP Auto',
        6: 'ASV',
        7: 'ASVAuto',
        8: 'iVAPS'
    };
    
    return modeMap[modeNum] || `Mode ${modeNum}`;
}

function sensitivityLabelFromValue(value) {
    const map = {
        4: 'very high',
        3: 'high',
        2: 'medium',
        1: 'low',
        0: 'very low'
    };
    const n = parseInt(value);
    return (n in map) ? map[n] : (value !== undefined && value !== null ? String(value) : 'N/A');
}

function getSessionPressureData(pressureSettings, sessionDate) {
    if (!pressureSettings || !pressureSettings.dailyData) {
        return null;
    }
    
    // Try to find pressure data for this specific date
    if (pressureSettings.dailyData[sessionDate]) {
        return pressureSettings.dailyData[sessionDate];
    }
    
    // If direct match fails, check if we have a date conversion issue
    // Try to find a date that could be the same logical date with different year
    const sessionDateParts = sessionDate.split('-');
    const sessionMonth = sessionDateParts[1];
    const sessionDay = sessionDateParts[2];
    
    // Look for dates with same month/day but different year
    for (const [strDate, data] of Object.entries(pressureSettings.dailyData)) {
        const strDateParts = strDate.split('-');
        if (strDateParts[1] === sessionMonth && strDateParts[2] === sessionDay) {
            console.log(`Found matching month/day: Using pressure data from ${strDate} for session on ${sessionDate}`);
            return data;
        }
    }
    
    // If not found, try nearby dates (within 1 day)
    const sessionDateObj = new Date(sessionDate);
    const nearbyDates = [];
    
    for (let i = -1; i <= 1; i++) {
        const testDate = new Date(sessionDateObj);
        testDate.setDate(testDate.getDate() + i);
        const testDateStr = testDate.toISOString().split('T')[0];
        if (pressureSettings.dailyData[testDateStr]) {
            nearbyDates.push({
                date: testDateStr,
                data: pressureSettings.dailyData[testDateStr],
                daysDiff: Math.abs(i)
            });
        }
    }
    
    // Return closest match
    if (nearbyDates.length > 0) {
        nearbyDates.sort((a, b) => a.daysDiff - b.daysDiff);
        console.log(`Using pressure data from ${nearbyDates[0].date} for session on ${sessionDate}`);
        return nearbyDates[0].data;
    }
    
    // If no nearby dates found, return null
    console.log(`No pressure data found for session date: ${sessionDate}. Available dates:`, Object.keys(pressureSettings.dailyData).slice(0, 5));
    return null;
}

// Machine identification parsing
async function parseMachineIdentification(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const content = event.target.result;
                let machineInfo = {};
                
                if (file.name.endsWith('.json')) {
                    // Parse JSON format (newer machines like AS11)
                    const jsonData = JSON.parse(content);
                    machineInfo = {
                        type: jsonData.ProductName || 'Unknown',
                        serial: jsonData.SerialNumber || 'Unknown',
                        softwareId: jsonData.SoftwareId || 'Unknown'
                    };
                } else if (file.name.endsWith('.tgt')) {
                    // Parse TGT format (older machines)
                    const lines = content.split('\n');
                    let productName = 'Unknown';
                    let serialNumber = 'Unknown';
                    let softwareId = 'Unknown';
                    
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('#PNA ')) {
                            productName = trimmed.substring(5).trim();
                        } else if (trimmed.startsWith('#SRN ')) {
                            serialNumber = trimmed.substring(5).trim();
                        } else if (trimmed.startsWith('#SID ')) {
                            softwareId = trimmed.substring(5).trim();
                        }
                    }
                    
                    machineInfo = {
                        type: formatMachineType(productName),
                        serial: serialNumber,
                        softwareId: softwareId
                    };
                }
                
                resolve(machineInfo);
            } catch (error) {
                reject(new Error(`Failed to parse machine identification: ${error.message}`));
            }
        };
        
        reader.onerror = function() {
            reject(new Error(`Failed to read file ${file.name}`));
        };
        
        reader.readAsText(file);
    });
}

function formatMachineType(productName) {
    if (!productName || productName === 'Unknown') {
        return 'Unknown';
    }
    
    // Convert underscores to spaces and clean up common ResMed naming
    return productName
        .replace(/_/g, ' ')           // Replace underscores with spaces
        .replace(/([a-z])([A-Z])/g, '$1 $2')  // Add spaces between camelCase
        .replace(/\s+/g, ' ')         // Remove extra spaces
        .trim();
}

// CSV Export function for nightly results
function exportNightlyCSV() {
    if (!window.originalNightlyData || window.originalNightlyData.length === 0) {
        alert('No data available to export. Please analyze some files first.');
        return;
    }

    // Get the data (same as what's displayed in the table)
    const nightlyData = window.originalNightlyData.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    // Create CSV headers
    const headers = [
        'Date',
        'Start Time', 
        'Duration (hours)',
        'Sessions',
        'Machine Type',
        'Overall GI',
        'Skew',
        'Spike', 
        'Flat Top',
        'Top Heavy',
        'Multi Peak',
        'No Pause',
        'Inspir Rate',
        'Multi Breath',
        'Variable Amp',
        'IPAP',
        'EPAP',
        'Pressure Support',
        'EasyBreathe',
        'Rise Time',
        'Trigger',
        'Cycle'
    ];
    
    // Create CSV rows
    const rows = nightlyData.map(night => [
        night.date,
        night.startTime,
        night.duration.toFixed(1),
        night.sessions.toString(),
        night.machineType || 'Unknown',
        night.weightedGI.overall.toFixed(2),
        night.weightedGI.skew.toFixed(2),
        night.weightedGI.spike.toFixed(2),
        night.weightedGI.flatTop.toFixed(2),
        night.weightedGI.topHeavy.toFixed(2),
        night.weightedGI.multiPeak.toFixed(2),
        night.weightedGI.noPause.toFixed(2),
        night.weightedGI.inspirRate.toFixed(2),
        night.weightedGI.multiBreath.toFixed(2),
        night.weightedGI.ampVar.toFixed(2),
        night.ipap !== 'N/A' ? night.ipap.toString() : 'N/A',
        night.epap !== 'N/A' ? night.epap.toString() : 'N/A',
        night.pressureSupport !== 'N/A' ? night.pressureSupport.toString() : 'N/A',
        (night.easyBreathe !== 'N/A' ? night.easyBreathe.toString() : 'N/A'),
        (night.riseTime !== 'N/A' ? night.riseTime.toString() : 'N/A'),
        (night.trigger !== 'N/A' ? night.trigger.toString() : 'N/A'),
        (night.cycle !== 'N/A' ? night.cycle.toString() : 'N/A')
    ]);
    
    // Combine headers and rows
    const csvContent = [headers, ...rows]
        .map(row => row.map(field => `"${field}"`).join(','))
        .join('\n');
    
    // Create and download the file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        
        // Generate filename with date range
        const firstDate = nightlyData[nightlyData.length - 1].date;
        const lastDate = nightlyData[0].date;
        const filename = `glasgow_index_${firstDate}_to_${lastDate}.csv`;
        
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        // Fallback for older browsers
        window.open('data:text/csv;charset=utf-8,' + encodeURIComponent(csvContent));
    }
}

</script>

</body>
</html>